package com.igorcrevar.rolloversphere.objects.boxes;

import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

import com.badlogic.gdx.graphics.PerspectiveCamera;
import com.badlogic.gdx.math.Vector3;
import com.igorcrevar.rolloversphere.collsion.CollisionSolver;
import com.igorcrevar.rolloversphere.collsion.ICollisionIterationHandler;
import com.igorcrevar.rolloversphere.objects.boxes.factory.IBoxesFactory;

public class BoxesManager implements ICollisionIterationHandler{
	private List<Box> mBoxes = new ArrayList<Box>();
	//list of all boxes intersected with passed spehere in doAll method
	private List<Box> mPickedBoxes = new ArrayList<Box>();
	//list of all boxes expired(timeouted) after update
	private List<Box> mExpiredBoxes = new ArrayList<Box>();
	
	private float mRadiusOfBall;
	private IBoxesFactory mBoxesFactory;	
	private float mHeight;
	private float mWidth;
	private float mMinX;
	private float mMinZ;
	
	public BoxesManager(IBoxesFactory bf){
		setBoxesFactory(bf);
	}
	
	public void init(float minX, float maxX, float minZ, float maxZ){
		this.mMinX = minX;
		this.mMinZ = minZ;
		this.mHeight = Math.abs(maxZ - minZ);
		this.mWidth = Math.abs(maxX - minX);
	}
	
	public void setBoxesFactory(IBoxesFactory bf){
		mBoxesFactory = bf;
	}
	
	public synchronized void addNew(Vector3 pos, float r){
		Box pb = mBoxesFactory.get();		
		pb.init();
		pb.position.y = 0.5f;
		
		boolean isCollided = false;		
		do{			
			pb.position.x = (float)(Math.random() * mWidth + mMinX);
			pb.position.z = (float)(Math.random() * mHeight + mMinZ);
			if (!CollisionSolver.isCollide(pos, r, pb.position, pb.boundingSphereR)){
				isCollided = false;
				for (Box t: mBoxes){
					if (CollisionSolver.isCollide(pb.position, pb.boundingSphereR, t.position, t.boundingSphereR)){
						isCollided = true;
						break;
					}
				}
			}
			else{
				isCollided = true;
			}
		}
		while (isCollided);
				
		mBoxes.add(pb);
	}
	
	/**
	 * Update boxes, remove not alive and render
	 * @param camera
	 * @param timeDiff
	 */
	public void updateAndRender(PerspectiveCamera camera, float timeDiff){
		int size = mBoxes.size();
		for (int i = size - 1; i >= 0; --i){
			Box box = mBoxes.get(i);	
			if (box.updateBox(timeDiff)){
				box.render(camera);
			}
			else{
				mBoxes.remove(i);
				mExpiredBoxes.add(box); //add to expired list
			}
		}
	}
	
	public List<Box> getCollided(Vector3 pos, float r){
		List<Box> rv = null;
		for (Box t: mBoxes){
			if (CollisionSolver.isCollide(pos, r, t.position, t.boundingSphereR)){
				if (rv == null){
					rv = new Stack<Box>();
					rv.add(t);
				}
			}
		}
		
		return rv;
	}
	
	public List<Box> getCollided(Vector3 posStart, Vector3 posEnd, float r){
		CollisionSolver.iterateOver(this, posStart, posEnd, null);	
	}
	
	public void remove(List<Box> pbs){
		for (Box pb : pbs){
			mBoxes.remove(pb);
		}
	}
	
	/**
	 * Check collision with sphere(center from posStart to posEnd and radius s) for every box
	 * remove collided boxes. update and render boxes 
	 * @return list of removed boxes
	 */
	public synchronized void doAll(PerspectiveCamera camera, float timeDiff, 
								   Vector3 posStart, Vector3 posEnd, float r){
		//TODO: create new class and pass this values to handler via tag object
		mPickedBoxes.clear();
		mRadiusOfBall = r;
		//call interpolation solved
		updateAndRender(camera, timeDiff);
	}
	
	public synchronized int getBoxesCount(){
		return mBoxes.size();
	}
	
	public synchronized int getNotUpgradeBoxCount(){
		int size = 0;
		for (Box box:mBoxes){
			if (box.getUpgrade() == UpgradeType.NOT_UPGRADE){
				++size;
			}
		}
		
		return size;
	}

	@Override
	public boolean iterationHandler(Vector3 position, Object tag) {
		List<Box> rv = getCollided(position, mRadiusOfBall);
		if (rv != null){
			//add to list of removed
			mRemovedBoxes.addAll(rv);
			//remove from list of existing boxes
			mBoxes.removeAll(rv);
		}
		
		return true;
	}
}
